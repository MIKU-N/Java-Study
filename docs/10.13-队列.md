## `ArrayList`与`Vector`差异

- `ArrayList`是在Java1.2版本以后采用变长数组算法实现的，线程不安全，但效率高速度快
- `Vector`在Java1.0版本出现，底层也是采用变长数组算法实现的，线程安全但效率低

## `ArrayList`和`LinkedList`差异

- `ArrayList`是采用变长数组算法来实现的，更适合查询数据
- `LinkedList`是采用双向链表结构来实现的，更适合频繁的增删操作

# 新循环(增强for循环[for each])

> JDK1.5版本后的新特性。

## 语法

```java
for(元素类型 e:集合/数组){
    //循环体
}
```

> 新循环有别于传统循环，其出现的目的是用于简化遍历集合/数组的。

## 例子

```java
package day10_13;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ForEachDemo {
	public static void main(String[] args) {
		String[] array = {"a","b","c","d","e"};
		//传统方式
		for(int i=0;i<array.length;i++) {
			System.out.println(array[i]);
		}
		//新循环方式
		for(String str:array){
			System.out.println(str);
		}
		List<String> list= new ArrayList();
		list.add("one");
		list.add("two");
		list.add("three");
		//传统方式
		for(int i=0;i<list.size();i++) {
			System.out.println(list.get(i));
		}
		//迭代器方式
		Iterator<String> it = list.iterator();
		while(it.hasNext()) {
			System.out.println(it.next());
		}
		//新循环方式
		for(String s:list) {
			System.out.println(s);
		}
		/*
		 * 新循环是通过迭代器实现的
		 * Java在编译时，会将新循环转换为迭代器的方式
		 * 那么在新循环遍历集合时，同样也不可以通过集合的方法增删元素
		 */
	}
}
```

# 队列(Queue)

> 队列也是用于保存一组数据的，但与数组和集合不一样的是，队列存取元素必须遵循先进先出的原则(FIFO)
>
> LinkedList具有存取效率高的特点，所以Java使用该类作为队列的实现类来使用
>
> 队列的遍历是一次性的，想要获取队列中的某个元素，就必须先将改队列中该元素之前的所有元素取出后才可以访问与使用

## 队列中的方法

`boolean offer(E e)` 	向队列末尾增加新元素（入队操作）

`E pool()`		获取并删除队首元素（出队操作）

`E peek()` 		仅获取队首元素，但不将其从队列中删除 

```java
package day10_13;

import java.util.LinkedList;
import java.util.Queue;

public class QueueDemo {
	/**
	 * 队列遵循先进先出原则
	 */
	public static void main(String[] args) {
		Queue<String> queue = new LinkedList<>();
		//入队操作
		queue.offer("one");
		queue.offer("two");
		queue.offer("three");
		queue.offer("four");
		System.out.println(queue);
		//打印队列长度
		System.out.println(queue.size());
		//获取队首元素（不同时删除）
		System.out.println(queue.peek());
		/*
		 * E poll()
		 * 如果队列中不包含任何元素，那么此方法会返回null
		 */
		//for循环
//		for(int i=queue.size();i>0;i++) {
//			System.out.println(queue.poll());
//		}
//		System.out.println(queue.poll());
		//while循环
//		String str = null;
//		while((str=queue.poll())!=null) {
//			System.out.println(str);
//		}
		//新循环,遍历完成后队列内仍存在
		for(String e:queue) {
			System.out.println(e);
		}
		System.out.println(queue);
	}
}
```

# 双端队列(Deque)

> 双端队列指的是队列两端都可以出队/入队
>
> 当我们使用双端队列来存取元素且只从一侧操作时，就形成了一种存取模式：先进后出；这是一种经典的数据结构：栈结构。
>
> 使用栈结构通常是为了操作具有可追溯性，例如常见的后退功能。

```java
package day10_13;

import java.util.Deque;
import java.util.LinkedList;

public class DqueDemo {
	/**
	 * 双端队列
	 * 该队列两端都可以出/入队
	 * 当我们只从一端操作时，就实现了栈结构(FILO)
	 */
	public static void main(String[] args) {
		Deque<String> stack= new LinkedList<>();
		/*
		 * void push(E e)
		 * 向栈中压入元素（压栈/入栈操作）
		 */
		stack.push("one");
		stack.push("two");
		stack.push("three");
		stack.push("four");
		System.out.println(stack);//[four, three, two, one]
		//获取栈顶元素 peek()
		System.out.println(stack.peek());//four
		/*
		 * E pop()
		 * 获取栈顶元素，同时从栈中移除该元素
		 * 当栈中不包含元素时，调用此方法会抛出异常(NoSuchElementException)
		 */
		for(int i=stack.size();i>0;i--) {
			System.out.println(stack.pop());
		}
		System.out.println(stack);
	}
}
```

# Collections工具类

> Collections是集合的工具类

## sort()方法

> 静态方法sort()用于针对List集合的元素排序

### 默认比较规则

Comparable接口:该接口的实现类具备可比较性

实现该接口必须重写其中的`compareTo()`方法，该方法用于定义具体的比较规则

#### 返回值

> 返回的证书并不关心具体值的大小，关心的是取值范围

- 当返回值>0	当前对象比给定对象大
- 当返回值>0	当前对象比给定对象小
- 当返回值=0	当前对象与给定对象相等

### 例子

> 比较队列中点到原点的距离，并根据距离排序队列

首先，创建Point类

```java
package day10_13;

/**
 * Point作为Comparable接口的实现类，
   *    该接口的实现类是具有可比较性的
 *
 */
public class Point implements Comparable<Point>{//点类
	private int x;
	private int y;
	public Point(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}
	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
	public int getY() {
		return y;
	}
	public void setY(int y) {
		this.y = y;
	}
	@Override
	public String toString() {
		return "(" + x + ", " + y + ")";
	}
	@Override
	//覆盖比较规则
	public int compareTo(Point o) {//this
		int thisLen= this.x*this.x+this.y*this.y;
		int oLen= o.x*o.x+o.y*o.y;
		return thisLen-oLen;
	}
	
}
```

其次，创建SortDemo测试类

```java
package day10_13;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class SortDemo {
	/**
	 * 排序集合
	 * Collections是集合的工具类
	 * 其中的静态方法sort()用于排序集合中的元素的
	 * 这里排序仅针对于List集合
	 */
	public static void main(String[] args) {
		List<Point> list= new ArrayList<>();
		list.add(new Point(1,5));
		list.add(new Point(3,4));
		list.add(new Point(2, 2));
		System.out.println(list);
		/*
		 * 报错原因:
		 * list集合中的Point对象不具备可比较性
		 */
		Collections.sort(list);
		System.out.println(list);
	}
}
```

